Date created: July 27, 2018;
Created by Royce:

Chapter 1. (Introduction)
	I. Installation
		What is PostgreSQL? 
			--> is an object-relational database management system (ORDBMS).
			--> ORDBMS - is a database management system similar to relational database but with an object-oriented database model.
							objects, classes and inheritance are directly supported in database schemas and in the query language.
			--> Object database  - An object database is a database management system in which information is represented in the form of objects as used in object-oriented programming. 
									Object databases are different from relational databases which are table-oriented. 
									Object-relational databases are a hybrid of both approaches.
			--> Developed at the University of California at Berkeley Computer Sciene Department.
			--> Written in C and the initial release was 29 January 1997.
			--> Postgres originates(pioneer) many concepts that only became available in some commercial database systems (Oracle, MSSQL, Teradata) much later.
			--> PostgresSQL is an original ancestor of open source database in Berkeley code. It supports a large part of the SQL standard and offers many modern features like:
					a. Complex queries - Complex SQL queries go beyond the standard SQL query commands such as SELECT. For example Consider the huge amount of data that would be present in a music database like Spotify. 
										Sometimes you want to search for more than just a single artist or album or maybe you want to pull together different subsets of data.
					b. Foreign keys - A FOREIGN KEY is a key used to link two tables together.
									  A FOREIGN KEY is a field (or collection of fields) in one table that refers to the PRIMARY KEY in another table. 
									  The table containing the foreign key is called the child table, and the table containing the candidate key is called the referenced or parent table.
					c. Triggers - is special stored procedure that is run when specific actions occur within a database. 
								  Most triggers are defined to run when changes are made to table's data.
					d. Updatable views - An updatable view is one which allows performing a UPDATE command on itself without affecting any other table.
					e. Transactional integrity - A transaction is a unit of work that is performed against a database. Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
					f. Multiversion concurrency control (MCC) - is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.
							Without concurrency control, if someone is reading from a database at the same time as someone else is writing to it, it is possible that the reader will see a half-written or inconsistent piece of data. 
							For instance, when making a wire transfer between two bank accounts if a reader reads the balance at the bank when the money has been withdrawn from the original account and before it has deposited in the destination account, it would seem that money has disappeared from the bank. 
			--> Also, PostgreSQL can be extended by the user in many ways, for example by adding new
					a. Data types - boolean, characters (char, varchar, text), numbers (integer, float), temporal (date, time, timestamp, timestampz, interval), Arrays, JSON, UUID,  Special(box, line, point, lseg, polygon, inet, macaddr)
					b. Functions - also known as Stored Procedures, allow you to carry out operations that would normally take several queries and round trips in a single function within the database. Functions allow database reuse as other applications can interact directly with your stored procedures instead of a middle-tier or duplicating code.
								   Functions can be created in a language of your choice like SQL, PL/pgSQL, C, Python, etc.
					c. Operators - is a reserved word or a character used primarily in a PostgreSQL statement's WHERE clause to perform operation(s), such as comparisons and arithmetic operations.
									- Arithmetic operators
									- Comparison operators
									- Logical operators
									- Bitwise operators
					d. Aggregate functions - An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the count, sum, avg (average), max (maximum) and min (minimum) over a set of rows.
					e. Index methods - This is referring to have an enhance database performance.
					f. Procedural language - PostgreSQL allows user-defined functions to be written in other languages besides SQL and C. These other languages are generically called procedural languages (PLs).
			--> And because of the liberal license, PostgreSQL can be used, modified and distributed by anyone free of charge for any purpose, be it private, commercial or academic.
		Brief History of PostgreSQL
			--> PostgreSQL is derived from the POSTGRES package written at UCal with over two decades of development behind it. Today PostgreSQL is now the most advanced open-soruce database availble anywhere.
			--> POSTGRES (data model) project led by Professor Michael Stonebraker was sponsored by DARPA, ARO, NSF and ESL INC.
			--> The implementation of POSTGRES began in 1986.
			--> The demoware system became operational in 1987 and was shown 1988 ACM-SIGMOD conference.
			--> Version 1 released to few external users in June 1989.
			--> They came up to redesign due to critique of the first rule sytem. Version 2 was released in June 1990 with new rule system.
			--> Version 3 appeared in 1991 and added support for multiple storage managers, an improved query executor and a rewritten rule system.
			--> Beyond 1991 POSTGRES has been used to implement many different research production application. These includes the ff:
					- Financial data analysis system
					- Jet engine performance monitoring package
					- Asteriod tracking database 
					- Medical information database 
					- Several geographic information systems
					- Educational tool at several universities
			--> In late 1992 Illustra information technicalogies commercialized it and POSTGRES became the primary data manager.
			--> The size of external user community doubled nearly during 1993. The more user the more bugs came out. It became increasingly maintenance and support.
				To reduce support burden the Berkeley POSTGRES project officially ended with version 4.2.
			--> In 1994, Andrew Yu and Jolly Chen added an SQL language interpreter to POSTGRES. Under a new name, Postgres95 was subsequently
					released to the web to find its own way in the world as an open-source descendant of the original POSTGRES Berkeley code.
			--> Postgres95 was faster than Version 4.2 base on Wisconsin benchmark. There are many enhancement including bug fixes.
			--> By 1996 it became clear that the name Postgres95 would not stand test of time. We chose new name PostgreSQL to reflect the relationalship 
				between the original POSTGRES and the more recent versions with SQL capability. At the same time, we set the version number to start 6.0
		Conventions
			--> An administrator is generally a person who is in charge of installing and running the server. 
				A user could be anyone who is using or wants to use any part of the PostgreSQL system.
	II. Architectural Fundamentals: 
		--> Architectural may refer to or in short for summary server and client model.
		--> In database jargon(technical terminology), PostgresSQL uses client / server models.
		--> PostgresSQL session consists of cooperating processes (running programs behind it).
			A. Server Process - This is for server process operations.
				- Manages database files.
				- Connections to the database from client applications.
				- Performs database actions on behalf of clients.
				- The database server program is called "POSTGRES".
			B. User - frontend application and user developer.
				- A front end application that wants to perform database operations.
				- Different types of application may refer to platform type of application.
					1. CLI - A client could be a text-oriented tool. For example task automations, library SDK.
					2. GUI - A graphical user interface application. For example desktop apps, web apps, mobile apps.
					3. Hosting environment - A web server that accesses the database to display web pages, or a specialized
									database maintenance tool. 
					4. Other - Some client applications are supplied with the PostgreSQL distribution; most are developed by users.
		--> PostgreSQL architectural model (server and client) they communicate over a TCP / IP network connection.
		--> Keep in mind the files that can be accessed on a client machine might not be accesseble. (or may accessible using a file name) on machine.
		--> PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts "fork" (replicating) a new process
			for each connection. The concept behind this statement is that tha postgres server is self replicating invocation. In short 
				it replicate itself rather than accepting connection.
		--> Master server(replicated postgres) is always running waiting for client connections. Whereas client and associated server processes  come and go.
		--> All this processes are invisible to the user. We are metion it here for completeness.

Chapter 2 (THE SQL LANGUAGE)
	I.Concepts
		--> PostgreSQL is relational database management system (RDBMS).That means it is a system for managing data stored in relations.
		--> Relation is essentially a mathematical term for table.
		--> Each table is a named collection of rows.
		--> Each row of a given table has the same set of named columns.
		--> Each column is of a specific data type.
		--> Tables are grouped into databases,  and a collection of databases managed by a single PostgreSQL server instance 
			constitues a database cluster.
	II. Creating a new table
		--> You can create new table by specifying the table name along with column names and their types.
			Example
				CREATE TABLE weather (
					city 		varchar(80),
					temp_lo 	int,  -- low temperature
					temp_hi 	int,  -- high temperature
					prcp		real  -- precipitation  real is 6 digits value only
					date		date
				)

				CREATE TABLE cities (
					name varchar(80),
					location point -- Geometric data type
				)
	III. Populating a table with Rows 
		--> INSERT statement is used to populate a table with rows.
			Example:
			--> Implicit way
				INSERT INTO weather VALUES ('San Francisco'), 46, 50, 0.25, '1994-11-27');
				INSERT INTO city VALUES ('San Francisco', '(-194.0, 53.0)');
			--> Explicit way 
				INSERT INTO weather (city, temp_lo, temp_hi, prcp, data) 
					VALUES ('San Francisco'), 46, 50, 0.25, '1994-11-27');
		--> For insert you can lst the columns in a different order if you wish.
		--> Many developers consider explicitly listing the columns better style than relying on the order of implicitly.
	IV. Querying a Table
		--> Quired is to retrieve data from a table.
		--> An SQL SELECT statement is used to do this.
			Example
				SELECT * FROM weather;
				--> * is a shorthand for all columns with this -> SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
				--> You can write expressions not just simple column references.
					-> SELECT city, (temp_hi + temp_lo) / 2 AS temp_avg, date FROM weather;
				--> AS - a clause that is used to relabel the output column.
				--> WHERE - a clause that specifies which rows are wanted. It contains Boolean (truth value) expression usally (AND, OR and NOT)
					-> SELECT * FROM weather WHERE city = 'Antipolo City' AND prcp > 2;
				--> ORDER - a clause that sort rows in order.
					-> SELECT * FROM weather ORDER BY city;
					-> SELECT * FROM weather ORDER BY city, temp_lo;
				--> DISTINCT - a clause that removes duplicate rows from the query result.
					-> SELECT DISTINCT city FROM weather ORDER by city;
		Notes:
			1. While SELECT * is useful for off-the-cuff queries, it is widely considered bad style in production code. 
				Since adding a column to the table would change the results.
	V. JOINS BETWEEN TABLES
		--> Thus far, our queries have only accessed one table at time.
		--> Queries can access multiple tables at once, or access the same table in such a way that multiple rows 
			of the table are being processed at the same time.
		--> Join - A query that accesses multiple rows of the same or different tables at one time.
		--> This statement is only a conceptual model. The join is usally performed in a more efficient manner.
		--> It is widely considered good style to qualify all column names in a join query, so that the query won't faile of a 
		duplicate column name is later added to one of the tables.
		--> Example
			SELECT * FROM weather, cities WHERE city = name;
			Types of JOIN
		--> Inner JOIN (http://prntscr.com/k7u9nu) (I)
			--> The SQL INNER JOIN is akin to set intersection
			--> Keyword is Intersect
			--> Selects rows from table1 and table2 where they match the selecting column.
			--> Example of Inner JOIN Concept http://prntscr.com/k7ufzp
			--> Example
				SELECT * FROM weather INNER JOIN cities ON (weather.city = cities.name);
		--> LEFT OUTER JOIN 
			--> Example
				SELECT * FROM weather LEFT OUTER JOIN CITIES ON (weather.city = cities.name)
		--> SELF JOIN
			--> We can also join a table against itself. This is called a self join.
			--> Example
			 	SELECT W1.city, W1.temp_lo AS low, W1.temp_hi as high, W2.city, W2.temp_lo AS low, W2.temp_hi as high FROM weather W1, weather W2 WHERE W1.temp_lo < W2. temp_lo AND W1.temp_hi > W2.temp_hi;
			--> Here we have relabeled the weather table as W1 and W2 to be able to distinguish the left and right side of the join.
			--> We can use this kind of aliases in other queries to save some typing.
			--> Example	
				SELECT * FROM weather w, cities c WHERE w.city = c.name;
			--> We will encounter this style of abbreviating quite frequently.
	VI. Aggregate Functions
		--> Like most other relational database products, PostgreSQL supports aggregate functions.
		--> Aggregate function - computes a single result from multiple input rows.
		--> Aggregate function - produced a single result for an entire group or table.
		--> Aggregate function -  are used to produce summarized results.
		--> Aggregate function - They operate on sets of rows. They return results based on groups of rows. By default, all rows in a table are treated as one group.
		--> Types of aggregate function that computes over a set of rows.
			A. count - This function returns the number or rows or non NULL values for a column
			b. sum   - This function returns the sum of a selected column.
			c. avg (average) - This function returns the average value for a specific column. 
			d. max (maximum) - This function returns the largest value of a specific column.
			e. min (minimum) - This function returns the smallest value of a specific column. 
		--> Example
			SELECT count(W1.temp_lo) FROM weather W1;
			SELECT sum(W1.temp_lo) FROM weather W1;
			SELECT avg(W1.temp_lo) FROM weather W1;
			SELECT max(temp_lo) FROM weather;
			SELECT min(temp_lo) FROM weather;
		--> Aggregate functions cannot be used inside WHERE claused. This restriction exists because the WHERE clause 
			determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before 
			aggregate functions are computed.
			SELECT city FROM weather WHERE temp_lo = max (temp_lo); # WRONG 
			SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather); # CORRECT
		--> This is valid because the subquery is an indenpendent computation that computes its own aggregate separately from 
			what is happening in the outer query.
		--> Aggregates also very useful in combination with GROUP BY clauses. For example we can get the maximum low temperature observed in each city.
		--> Example
			SELECT city, max(temp_lo) FROM weather GROUP BY city;
			SELECT w.city, max(w.temp_lo) FROM weather w GROUP BY w.city;
		--> Each aggregate result is computed over the table rows matching that city. We can filter these grouped row using HAVING
		--> Example
			SELECT city, max(temp_lo) FROM weather GROUP by city HAVING max(temp_lo) < 40;
		--> SELECT city, max(temp_lo) FROM weather WHERE city LIKE 'S%' GROUP BY city HAVING max(temp_lo) < 40;
		--> The LIKE operator does pattern matching
		--> The understanding and interaction between aggregates SQL WHERE and HAVING caluses.
		--> WHERE - selects input rows BEFORE groups and aggregates are computed (it controls which rows go into the aggregate computation).
		--> HAVING - whereas HAVING selects group rows AFTER groups and aggregates computed.
		--> Thus, the WHERE clause must not contains aggregate functions; it makes no sense to try to use an aggregate to determine 
			which rows will be inputs to the aggregates.
		--> On the other hand, the HAVING clause always contains aggregate functions. (Stricly speaking, you are allowed to write a HAVING clause 
		that doesn't user aggregates) but it's seldom useful.
	VII. Updates
		--> You can update existing rows using the UPDATE command.
		--> Example
			UPDATE weather SET temp_hi = temp_hi -2, temp_lo = temp_hi -2 WHERE date > '1994-11-28';
	VIII. Deletions
		--> Rows can be removed from a table using DELETE command. 
		--> Example
			DELETE FROM weather WHERE city = 'Hayward';
		--> To remove all rows from a given table, leaving it empty. (THE SYSTEM WILL NOT REQUEST CONFIRMATION BEFORE DOING THIS!)
			DELETE FROM <tablename>
			DELETE FROM weather;
Chapter 3 (Advanced Features)
	I. Introduction
		--> We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your 
			data. We will look some PostgreSQL extensions.
	II. Views
		--> Views are pseudo-table (Implicit).
		--> A view can contain all rows of a table or selected rows from one or more tables.
		--> A view can be created from one or many tables, which depends on the written PostgreSQL query to create a view.
		--> Views allow you to encapsulate the details of the structure of your tables, which might change as your 
		application evolves, behind consistent interfaces.
		--> A view can represent a subset of a real table, selecting certain columns or certain rows from an ordinary table. 
		--> A view can even represent joined tables.
		--> Because views are assigned separate permissions, you can use them to restrict table access so that the users see only specific rows or columns of a table.
		--> Views, which are kind of virtual tables, allow users to do the following
			1. Structure data in a way that users or classes of users find natural or intuitive.
			2. Restrict access to the data such that a user can only see limited data instead of complete table.
			3. Summarize data from various tables, which can be used to generate reports.
		--> Example
			1. CREATE VIEW myview AS 
				SELECT city, temp_lo, temp_hi, prcp, date, location FROM weather, cities WHERE city = name;
			2. SELECT * FROM myview;
		--> Droppin Views 
			DROP VIEW <view_name>;
			DROP VIEW myview;
	III. Foreign keys	
		--> A concept behind foreign keys is you want to make sure that no one can insert rows in the weather table that do not 
			have a matching entry in the cities table. This is called maintaining referential integrity of your data.
		--> In simplistic database systems this would be implemented (if at all).
		--> Example
			CREATE TABLE cities (
				city VARCHAR(80) PRIMARY KEY,
				location POINT 
			);
			CREATE TABLE weather (
				city VARCHAR(80) REFERENCES cities(city),
				temp_lo INT, 
				temp_hi INT,
				prcp REAL,
				date DATE
			);
			INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
			ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
			DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
			* To fix this need to insert first into cities table because it reference to weather table.
	IV. Transactions
		--> A transaction is a unit of work that is performed against a database.
		--> Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
		--> A transaction is the propagation of one or more changes to the database. 
			For example, if you are creating a record, updating a record, or deleting a record from the table, then you are performing transaction on the table. 
			It is important to control transactions to ensure data integrity and to handle database errors.
		--> Properties of transaction
			1. Atomicity - Ensures that all operations within the work unit are completed successfully; otherwise, the transaction is aborted at the point of failure and previous operations are rolled back to their former state.
			2. Consistency - Ensures that the database properly changes states upon a successfully committed transaction.
			3. Isolation - Enables transactions to operate independently of and transparent to each other.
			4. Durability -  Ensures that the result or effect of a committed transaction persists in case of a system failure.
		--> Transaction control 
			1. BEGIN - to start transaction.
			2. COMMIT - to end transaction.
			3. ROLLBACK - to rollback the changes.
		--> Transactions - are a fundamental concept of all database systems. The essential point of a transaction is that 
			it bundles multiple steps into single, all-or-nothing operation. The intermediate states between the steps 
			are not visible to other concur transactions, and if some failure occurs that prevents the transaction 
			from completing, the none of the steps affect the database at all.
		--> A transaction is said to be atomic from the point of view of other transactions it either happens completely or 
			not at all.
		--> Example
			UPDATE accounts SET balance = balance - 100.00
    			WHERE name = 'Alice';
			UPDATE branches SET balance = balance - 100.00
    			WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
			UPDATE accounts SET balance = balance + 100.00
    			WHERE name = 'Bob';
			UPDATE branches SET balance = balance + 100.00
   				 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
		--> The details of these commands are not important here; the important point is that there are several separate updates 
			involved to accomplish this rather simple operation.
		--> We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has 
			been permanently recorded and won't be lost even if a crash ensues shortly thereafter.
		--> Another important property of transactional database is closely related to the notion of atomic updates:
			when multiple transactions are running concurrently, each one should not be able to see the incomplete changes 
			made by others.
		--> Transaction is being used for banking transaction.
		--> Example 
			BEGIN;
				<SQL STATEMENT>
			COMMIT;
			BEGIN;
				UPDATE accounts SET balance = balance - 100.00
					WHERE name = 'Alice';
			-- etc etc 
			COMMIT;
		--> If the balance went negative value, we can issue the command ROLLBACK instead of COMMIT, and all our updates so 
			far will be canceled.
		--> If you do not issue a BEGIN command in the statement, each invidual statement has an 
			implicit BEGIN and (if successful) COMMIT wrapped around it.
		--> A group of statements surrounded by BEGIN and COMMIT is sometimes called transactional block.
		--> It's possible to control the statement in a transaction in more granular (appearing) fashion
			through the use of savepoints.
		--> Savepoints - allow you to selectively discard parts of the transaction, while committing the rest.
		--> After defining a savepoint with SAVEPOINT, you can if needed roll back to the savepoint with 
			ROLLBACK TO. All the transaction's database changes between difning the savepoint and rolling back 
			to it are discarded, but changes earlier thatn the savepoint are kept.
		--> After rolling back to a savepoint, it continues to be defined. Meaning if you came back to a savepoint the current state 
			will be based on it. So you can roll back to it several times.
		--> All this thing is happening within transactional block, so nont of it is visible to other database sessions.
		--> When and if you commit the transactional block, the committed actions become visible as a unit to other sessions.
		--> While the rolled-back actions never become visible at all.
		--> Example
			BEGIN;
				UPDATE accounts SET balance  = balance - 100.00 WHERE name = 'Alice';
			SAVEPOINT my_savepoint;
				UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob';
			ROLLBACK TO my_savepoint;
				UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Walley';
			COMMIT;
		--> This example is of course oversimplified but there's a lot of control possible in a transaction block 
			through the use of savepoints. 
		--> Moreover ROLLBACK TO is the only way to regain control of transaction block that was put in aborted state
			by the sytem due to an error, short of rolling it back completely and starting again.
	V. Window Functions
		--> The term window describes the set of rows on which the window function operates. A window function returns a value from the rows in a window.
		--> Window function - performs a calculation across a set of table rows that are somehow related 
			to the current row. This is comparable to the type of calculation that can be done with aggregate function.
		--> Aggregate functions reduces the number of rows returned by the queries but window functions operates in set of rows, but 
			it does not reduce the number of rows returned by the query.
		--> However, window functions do not cause rows to become grouped into a single output row lie non-window aggregate calls would.
		--> Example
			SELECT depname, empno, salary avg(salary) OVER (PARTITION by depname) FROM empsalary;
		--> A window function call always contains an OVER clause directly following the window function's name and argument(s).
		--> This is what syntactically distinguishes it from a normal function or non-window aggregate.
		--> The OVER clause determines exactly how the rows of the query are split up for processing by the window function.
		--> The PARTITION By clause within OVER divides the rows into groups, or partitions that share the same values f the PARTITION BY expression.
		--> You can also control the order in which rows are processed by window functions using ORDER BY within OVER.
		--> Example
			SELECT depname, empno, salary, rank() OVER (PARTITION by depname ORDER BY salary DESC) FROM empsalary;
		--> As from the query the rank() function produces a numerical rank for each distinct ORDER BY value in the current 
			row's position.
		--> There is another import concept associated with window functions: for each row, there is a set of rows 
			within its partition called its window frame.
		--> Some window functions act only on the rows of the window frame, rather than of the whole partition.
		--> Example
			SELECT salary, sum(salary) OVER () FROM empsalary;
			SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
	VI. Inheritance 
		--> Inheritance is a concept from object-oriented databases. It opens up interesting new posibilities of database design.
		--> Example
			A. Normal way 
				CREATE TABLE capitals (
					name       text,
					population real,
					altitude   int,    -- (in ft)
					state      char(2)
				);
				CREATE TABLE non_capitals (
					name       text,
					population real,
					altitude   int     -- (in ft)
				);
				CREATE VIEW cities AS
				SELECT name, population, altitude FROM capitals
					UNION
				SELECT name, population, altitude FROM non_capitals;
			B. Inheritance way (better solution is this):
				CREATE TABLE cities (
					name 		text,
					population  real,
					altitude 	int
				);
				CREATE TABLE capitals (
					state char(2),
				) INHERITS (cities);
			--> In this case, a row of capitals inherits all columns (name, populate, altitude) from its parent cities.
			--> In PostgreSQL, a table can inherit from zero or more other tables.
			--> Example a query finds names of all cities including state capitals
				SELECT name, altitude FROM cities WHERE altitude > 500;
			--> Since capitals inherit all of columns in cities the result set for this query are combined capitals and cities.
			--> Example a query that finds all the cities that are not state capitals
				SELECT name, altitude FROM ONLY cities WHERE altitude > 500;
			--> The output for this query is for parent only.
			--> Here the ONLY before cities indicates that the query should over only the cities table, and not tables below cities
				in the inheritance hierarchy.
			--> SELECT, UPDATE and DELETE  supports this ONLY clause notation.
Chapter 4 SQL Syntax
	I. Lexical structure	
		A. Introduction
			--> SQL input consists of a sequence of commands.
			--> A command is composed of a sequence of tokens, terminated by a semicolon (";").
			--> The end of the input stream also terminates a command.
			--> Which tokens are valid depends on the syntax of the particular command.
			--> Tokens - in SQL is a sequence or group of SQL characters separated by comments, whitespace or oher SQL special character.
			--> Tokens - The basic syntactical units of the SQL language are called tokens. A token consists of one or more characters of which none are blanks, control characters, or characters within a string constant or delimited identifier.
			--> A token can be
				1. key word  such as SELECT or INSERT
				2. Identifier - identify names of tables, columns or other database objects. For example MY_TABLE, A
				3. Quoted identifier 
				4. literal (or constant) or a special character symbol. Such as literal (123, 'John') special character ((), =)
			--> Tokens are normally separated by whitespace (space, tab, newline)
			--> Example the ff syntactically valid SQL input
				SELECT * FROM MY_TABLE;
				UPDATE MY_TABLE SET A = 5;
				INSERT INTO MY_TABLE VALUES (3, 'hi there');
			--> Additionally, comments can occur in SQL input. Ther are not tokens, they are effectively equivalent to whitespace.
			--> The SQL 
		B. Identifiers and Key Words
			--> Tokens such as SELECT, UPDATE, or VALUES in the example above are example of key words. In which words that 
				have fixed a meaning in the SQL language.
			--> The tokens MY_TABLE and A are example of identifiers because they identify name of tables, columns or database objects depending 
				on the command they are used in.
			--> SQL identifiers and key words must begin with 
				1. letter (a-z, but also letters with diacritical marks and non-Lating letters)
				2. underscore _
				3. digits (0-9)
			--> Example
				UPDATE MY_TABLE SET A = 5;
				- can be equivalent be written as 
				uPDaTE my_TabLE SeT a = 5;
			--> A convention often used is to write key words in upper case and names in lower case.
			--> Example
				UPDATE my_table SET a = 5;
			--> There is second kind of identifier: the delimited or quoted identifier. It is formed by enclosing 
				an arbitrary sequence of characters in double-quotes (""). 
			--> A delimited identifier is always an identifier, never a key word.So "select" could be used to refer to column or 
				table named "select", whereas an unqouted select would be taken as a key word and would therefore provoke a parse error 
				when used where a table or column name is expected.
			--> Example
				UPDATE "my_table" SET "a" = 5;
			--> Quoted identifiers can contain any character, except the character with code zero.
		C. Constants
			--> There are three kinds of implicitly-typed constants in PostgreSQL
				1. strings
				2. bit strings
				3. numbers
			--> Constants can also specified with explicit types, which can enable more accurate representation and more efficient
				handling by the system.
			I. String Constants
				--> A string contstant in SQL is an arbitrary sequence of characters bounded by single quotes (').
				--> Example
					'This is a string.'
				--> To include a single-quote character within a string constant, write two adjacent single quotes.
					'Dianne''s hores'.
				--> Two string constants that are only separated by whitespace with at least one newline are concatenated and 
					effectively treated as if the string had been written as one constant.
				--> Example
					SELECT 'foo' 'bar';
					is equivalent to 
					SELECT 'foobar';
					SELECT 'foo'  'bar'; - Not a valid syntax.
			II. String Constants with C-style Escapes
				--> PostgreSQL also accepts "escape" string constants, which are an extension to the SQL standard.
				--> An escape string constant is specified by writing the letter E (upper or lower case) just before 
					the opening single quote, e.g., E'foo'.
				--> Example
					INSERT INTO customer (name, price) VALUES (E'Royce', 1);
					INSERT INTO cities2 (name, population, altitude) VALUES (E'Antipolo', 5000, 201);
				--> Within an escape string, a backlash character (\) begins a C-like backlash escape sequence.
				--> Backlash Escape Sequences
					1. \b  	- backspace 
					2. \f 	- form feed 
					3. \n 	- new line 
					4. \r 	- carriage return
					5. \t 	- tab
			III. String Constants with Unicode Escapes
				--> PostgreSQL also supports another type of escape syntax for the strings that allows specifying arbitrary 
					Unicode characters by code point.
				--> A Unicode espace string constants starts with U& (upper or lower case letter U followed by ampersand).
				--> Example
					U&'foo'.
			IV. Dollar-quoted String Constants
				--> To allow more readable queries in such situations, PostgreSQL provides another way called a doubled
					'dollar quoting', to write string constants.
				--> A dollar-quoted string constant consists of dollar sign ($), an optional "tag", another dollar sign,
					an arbitrary sequence of characters.
				--> Example
					'Dianne''s horse'. (VALID)
					"Dianne's horse" (VALID)
					$$Dianne's horse$$ (VALID)
					$<tagname>$Dianne's hores $<tagname>$ (VALID SYNTAX)
					$boom$Dianne's horse$boom$;
			V. Bit-string Constants
				--> Bit-string constants look like regular string constants with a B(upper or lower case) immediately
					before the opening quote.
				--> Bit strings are strings of 1's and 0's. They can be used to store or visualize bit masks.
				--> Example
					B'1001'
					CREATE TABLE test (a BIT(3), b BIT VARYING(5));
					INSERT INTO test VALUES (B'101', B'00');
					INSERT INTO test VALUES (B'10', B'101');
					INSERT INTO cities2 (name, population, altitude) VALUES (B'0111001001101111011110010110001101100101', 5000, 201);
				--> The only characters allowed within bit-string constants are 0 and 1.
				--> No space in binary sequence.
				--> Alternatively, bit-string constants can be specified in hexadecimal notation
				--> Example
					X'1FF'.
				--> This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.
			VI. Numeric Constants
				--> Digits is one or more decimal digits (0 through 9).
				--> There cannot be any spaces or other characters embedded in the constant.
				--> Example
					42
					3.5
					4.
					.001
					5e2
					1.925e-3
				--> Numeric constants contains neither decimal point nor an exponent.
				--> Numeric types 
					1. smallint 
					2. integer
					3. bigint 
					4. decimal
					5. numeric 
					6. real 
					7. double precision 
					8. serial 
					9. bigserial
			VII. Constants of other types 
				--> The string constants text is passed to the inut conversion routine for the type called type.
				--> Example
					typename ('string')

		D. Operators
			--> An operator name is a sequence of up to NAMEDATALEN-1
				1. + 	- Addition
				2. -  	- Substraction 
				3. *	- Multiplication
				4. / 	- Division 
				5. <	- Less than 
				6. > 	- Greater than 
				7. = 	- Assignment 
				8. ~	- Bit wise NOT
				9. ! 	- Not 
				10. @ 	- Variable names
				11. #	- ?
				12. %	- Modulo (remainder)
				13. ^ 	- Bitwise XOR
				14. &   - Bitwise AND 
				15. |	- Bitwise OR
				16. ` 	- String
				17. ? 	- ternary
		E. Special Characters 
			1. $ 	- used to represent positional parameter in the body in other context dollar sign can be part of identifier.
			2. () 	- usual meaning is to group expressions and enforce precedence. In some cases it is required as part of 
						fixed syntax of particular SQL command.
			3. [] 	- used to select elements of an array.
			4. , 	- are used in some syntactical constructs to separate elements of a list.
			5. ; 	- terminates an SQL command.
			6. : 	- is used to slices from arrays
			7. * 	- is used some contexts to denote all of the fields of a table row or composite value.
			8. . 	- used in numeric constants, and to separate schema, table, column names.
		F. Comments
			--> A comment is a sequence of characters beginning with double dashes and extending to the end of line.
			--> Example
				-- This is a standard SQL comment 
			--> C-style block comments
				/* multiline comment 
				 * with nesting: / * nested block comment */ 
				 */
			--> A comment is removed from the input stream before further syntax analysis and is effectively replaced by whitespace.
		G. Operator Precedence 
			--> Most operators have the same precedence and are left-associative.
			--> Example
				SELECT 5 ! - 6;
				will be parsed as 
				SELECT 5 ! (-6);
	II. Value Expressions
		--> are used in variety of contexts
		--> such as in the target list of the SELECT, INSERT, UPDATE commands.
		--> The result of a value expression is sometimes called a scalar, to distinguish it from the result of table expression.
		--> Value expression are therefore also called scalart expression (or even simply expression).
		--> The expression syntax allows the calculation of values from primitive parts using 
			arithmetic, logical, set and other operations.
		--> A value expression is one of the ff .
			1. A constant or literal value - string constants
			2. A column reference
			3. A positional parameter reference, in the body of a function definition or prepared statement
			4. A subscripted expression
			5. A field selection expression
			6. An operator invocation
			7. A function call
			8. An aggregate expression
			9. A window function call
			10. A type cast
			11. A collation expression
			12. A scalar subquery
			13. An array constructor
			14. A row constructor
				15. Another value expression in parentheses (used to group subexpressions and override precedence)
		A. Column references 
			--> A column can be referenced in form 
				correlation.columnname
			--> correlation - is the name of a table (possibly qualified with a schema name), or an alias for a table 
				defined by means of a FROM clause. The correlation name and separating dot can be omitted 
				if the column name is unique accorss all the tables being used in the query.
		B. Positional Parameters 
			--> A positional parameter reference is used to indicate a value that is supplied externally
				to an SQL statement. Parameters are used in SQL function definitions and in prepared queries.
			--> Example
				$number 
			--> Consider the definition of a function, dept 
				CREATE FUNCTION dept(text) RETURNS dept 
					AS $$ SELECT * FROM dept WHERE name = $1 $$
					LANGUAGE SQL;
			--> Here the $1 references the value of the first function argument whenever the function is invoked.
			--> Positional parameters preceding $, $1,$2,$3 and so on.
		C. Subscripts
			--> If an expression yield a value of an array tye, then a specific element of the array value 
				can be extracted by writing.
			--> Example
				expression[subscript]
			--> or multiple adjacent elements (an "array slice")
			--> Example
				expression[lower_subscript:upper_subscript]
			--> Here the brackers [] are meant to appear literally Each subscript is itself an expression, which must yield 
				an integer value.
		D. Field Selection
			--> If an expression yields a value of composite type (row type), then a specific field of the 
				row can be extracted by writing 
			--> Example
				expression.fieldname
				mytable.mycolumn
				$1.somecolumn
		E. Operator Invocations 
			--> There are three possible syntaxes for an operator invocation
				expression operator expression (binary infix operator)
				operator expression (unary prefix operator)
				expression operator (unary postfix operator)
			--> Where the operator token follows the syntax or is one of the key words AND, OR and NOT
			--> Example
				OPERATOR(schema.operatorname)
		F. Functions Calls
			--> The syntax for a function call is the name of a function (possibly qualified with a schema name)
			--> function_name([express])	
			--> Example
				sqrt(2)
		G. Aggregate Expressions
			--> An aggregate expression represents the application of an aggregate function across the rows selected by 
				query. An aggregate function reduces multiple inputs to a single output value.
		H. Window Function Calls
			--> A window function call represents the application of an aggregate-like function over some portion of the rows selected by 
				query.
		I. Type Casts
			--> A type cast specifies a conversion from one data type to another.
			--> CAST (expression AS type)
			--> expression::type
		J. Collation Expressions
			--> The COLLATE clause overrides the collation of an expression.
			--> Example
				expr COLLATE collation
		K. Scalar Subqueries
			--> A scalar subquery is an ordinary SELECT query in parentheses that returns exactly one row with one column.
			--> Example
				SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name) FROM states;
		L: Array Constructors
			--> An array constructor is an expression that builds an array value using values for its member elements.
			--> A simple array constructor consists of the keyword ARRAY.
			--> Example
				SELECT ARRAY[1,2,3+4];
				SELECT ARRAY[1,2,22.7]::integer[];
				SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
				SELECT ARRAY[[1,2],[3,4]];
				CREATE TABLE arr(f1 int[], f2 int[]);
				INSERT INTO public.arr (f1, f2) VALUES (ARRAY[[1,2], [3,4]], ARRAY[[5,6], [7,8]]);
				SELECT ARRAY[]::integer[];
					--> You can construct an empty array, but since it's impossible to have an array with no type, 
						you must explicitly cast your empty array to the desired type.
				SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
					--> Its possible to construct an array from the results of a subquery.
		M: Row Constructors
			--> A row constructor is an expression that builds a row value (also called a composite value)
				using values for its member fields. 
			--> A row constructor consists of the key word ROW, a left parenthesis, zero or more expressions 
			--> Example
				SELECT ROW (1,2.5, 'this is a test');
			--> The key word ROW is optional when there is more the one expression in the list.
			--> By default the value created by ROW expression is of an anonymous record type.
			--> Example
				CREATE TABLE mytable(f1 int, f2 float, f3 text);
				CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
				SELECT getf1(ROW(1,2.5,'this is a test'));
				-
				CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
				CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;
				SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
				SELECT getf1(CAST(ROW(11, 'this is a test', 2.6) AS myrowtype));
			--> Also it is possible to compare two row values or test a row IS NULL or IS NOT NULL?.
			--> Example
				SELECT getf1(CAST(ROW(11, 'this is a test', 2.6) AS myrowtype));
		N. Expression Evaluation Rules
			--> The order of evaluation of subexpression is not defined.
			--> In particular, the inputs of an operator or function are not necessarily evaluated left-to-right
			--> SELECT true OR somefunc();
			--> SELECT somefunc() OR true;
			--> A CASE construct used in this fashion will defeat optimization attemps, so it should only be done 
				when necessary.
			--> Example
				SELECT CASE WHEN min(employees) > 0 THEN avg(expenses / employees) END FROM departments;
	
	III. Calling Functions
		--> PostgreSQL allows functions that have named parameters to be called using either 
			positional or named notation
		--> Named notation is especially useful for functions that have a large number of parameters, 
			since it makes the associations between parameters and actual arguments more explicit and reliable.
		--> Positional notation a function call is written with its argument values in the same order as they 
			are defined in the function declaration.
		--> Mixed notation PostgreSQL also supports which combines positional and named notation.
		--> In this case position parameters are written first and named parameters appear after them.
		--> Example is the usage of all three notations
			CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
				RETURNS text 
				AS 	
				$$
					SELECT CASE 
							WHEN $3 THEN UPPER($1 || ' ' || $2)
							ELSE LOWER ($1 || ' ' || $2)
							END;
				$$
				LANGUAGE SQL IMMUTABLE STRICT;
				OUTPUT:
				CREATED FUNCTION

			A. Using Positional Notation
				--> Positional notation is the tradional mechanism for passing arguments to functions in PostgreSQL.
				--> Example
					SELECT concat_lower_or_upper('Hello', 'World', true);
					OUTPUT:
						concat_lower_or_upper
					    -----------------------
						HELLO WORLD
						(1 row)
					SELECT concat_lower_or_upper('hello', 'world');
					OUTPUT:
						concat_lower_or_upper
					    -----------------------
						hello world
						(1 row)
				--> In positional notation, arguments can be omitted from right to left so long as they have defaults.
			B. Using Named Notation
				--> In named notation, each argument's name is specified => to separate it from the argument expression.
				--> Example
					SELECT concat_lower_or_upper(a => 'Hello', b => 'World');
					OUTPUT:
						concat_lower_or_upper
					    -----------------------
						hello world
						(1 row)
				--> One advantage of named notation is that the arguments may be specified in any order.
				--> Example
					SELECT concat_lower_or_upper(a => 'Hello', b => 'World', uppercase => true);
					OUTPUT:
						concat_lower_or_upper
					    -----------------------
						HELLO WORLD
						(1 row)
					SELECT concat_lower_or_upper(a => 'Hello', uppercase => true, b => 'World');
					OUTPUT:
						concat_lower_or_upper
					    -----------------------
						hello world
						(1 row)
				--> An older syntax based on ":=" is  supported for backward compatibility
					SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
					OUTPUT:
						concat_lower_or_upper
					    -----------------------
						HELLO WORLD
			C. Using Mixed Notation
				--> The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot 
					precede positional arguments.
				--> Example
					SELECT concat_lower_or_upper('Hello', 'World', uppercase => true);
					OUTPUT:
						concat_lower_or_upper
					    -----------------------
						HELLO WORLD
						(1 row)

					CREATE FUNCTION try (a int, state boolean DEFAULT false)
						RETURNS INT 
						AS
						$boom$
							SELECT balance FROM accounts WHERE name = $1;
							$1 || 100
						$boom$
						LANGUAGE SQL IMMUTABLE STRICT;
					SELECT try (a := 'Walley', state := true);
					OUTPUT: 
						try
						------
						1100
						(1 row)

					CREATE OR REPLACE FUNCTION total_accounts(state boolean DEFAULT false)
						RETURNS INT 
						AS 
						$boom$
							DECLARE total INT;
							BEGIN 
								IF state = true THEN 
									SELECT sum(balance) INTO total FROM accounts;
									RETURN total;
								ELSE 
									SELECT ROW(0) INTO total;
									RETURN total;
								END IF;
							END;
						$boom$
							LANGUAGE plpgsql;
						OUTPUT:
						total_accounts
							----------------
          				 1800
						(1 row)
					CREATE OR REPLACE FUNCTION primes (IN integer) RETURNS TEXT AS 
						$BODY$
							DECLARE
								counter INTEGER = $1; 
								primes int []; 
								mycount int; 
							BEGIN
								WHILE counter != 0 LOOP 
									mycount := count(primes); 
									primes  := array_append(primes, mycount);
									counter := counter - 1; 
 									raise notice '%', counter; -- log anything
								END LOOP;
								RETURN array_to_string(primes, ',');   
							END;   
						$BODY$ LANGUAGE plpgsql;
					OUTPUT:
						NOTICE:  2
						NOTICE:  1
						NOTICE:  0
						primes
						--------
						0,1,1
						(1 row)
					SELECT primes(3);
				
Chapter 5 (Data Definition)
	--> This chapter covers how one creates the database structures that will hold one's data.
	I. Table Basics
		--> A table in a relational database is much like a table on paper: It consists of rows and columns.
		--> The number and order of the columns is fixed, and each column has a name.
		--> The number of rows is variable (not consistent or liable to change) — it reflects how much data is stored at a given moment.
		--> SQL does not make any guarantees about the order of the rows in a table. 
			When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested.
		--> Each column has a data type.
		--> Frequently used data type
			1. integer - this is for whole number
			2. numeric - for possibly fractional numbers typcal of monetary amounts.
			3. text - for character strings
			4. date - for dates 
			5. time - for time-of-day
			6. timestamp - for values containing both date and time.
		--> Example
			CREATE TABLE my_first_table (
				first_column text,
				second_column integer
			)
		--> There is a limit on how many columns a table can contain. 
		--> It is between 250 and 1600.
		--> However, defining a table with anywhere near this many columns is highly unusual and often a questionable design.
		--> If you no longer need a table, you can remove it using the DROP TABLE command. For example:
		--> Example
			DROP TABLE products;
			OUTPUT:
				DROP TABLE
		--> Attempting to drop a table that does not exist is an error. If that command execute it ignores errror.
		--> DROP TABLE IF EXISTS;
		--> DROP TABLE products IF EXISTS;
	II. Default Values 
		--> A column can be assigned a default value.
		-->  When a new row is created and no values are specified for some of the columns, 
			 those columns will be filled with their respective default values.
		-->  If no default value is declared explicitly, the default value is the null value.
		--> This usually makes sense because a null value can be considered to represent unknown data.
		--> Example
			CREATE TABLE products (
				product_no integer,
				name text,
				price numeric DEFAULT 9.99
			);
		--> The default value can be an expression, which will be evaluated whenever the default value is inserted (not when the table is created).
	III.Constraints
		--> Data types are a way to limit the kind of data that can be stored in a table.
		--> The constraint they provide is too coarse(rough / harsh).
		--> Constraints give you as much control over the data in your tables as you wish.
		--> If a user attempts to store data in a column that would violate a constraint, an error is raised.
		--> This applies even if the value came from the default value definition.
		--> Concept
		--> For example, a column containing a product price should probably only accept positive values.
			But there is no standard data type that accepts only positive numbers.
			Another issue is that you might want to constrain column data with respect to other columns or rows.
			For example, in a table containing product information, there should be only one row for each product number.
		A. Check Constraints
			--> A check constraint is the most generic(not specific) constraint type.
			--> It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. 
			--> Example (IMPLICIT WAY)
				CREATE TABLE products (
					product_no integer,
					name text,
					price numeric CHECK (price > 0)
				);
				INSERT into public.products (product_no, name, price) VALUES (1, 'Shampoo', 1); (This is valid query)
				OUTPUT:
					INSERT 0 1
				INSERT into public.products (product_no, name, price) VALUES (1, 'Shampoo', -1); (Invalid because the price value didn't meet the constrain);
				OUTPUT:
					ERROR:  new row for relation "products" violates check constraint "products_price_check"	
					DETAIL:  Failing row contains (1, Shampoo, -1).
			-->  A check constraint consists of the key word CHECK followed by an expression in parentheses.
			-->  The check constraint expression should involve the column thus constrained, 
				 otherwise the constraint would not make too much sense.
			--> You can also give the constraint a separate name. 
				This clarifies error messages and allows you to refer to the constraint when you need to change it.
			--> Example (Explicit)
				CREATE TABLE products (
					product_no integer,
					name text,
					price numeric CONSTRAINT positive_price CHECK (price > 0)
				);
			--> So, to specify a named constraint, use the key word CONSTRAINT followed by an identifier followed by the constraint definition.
			--> If you don't specify a constraint name in this way, the system chooses a name for you.
			--> A check constraint can also refer to several columns. 
				Say you store a regular price and a discounted price, 
				and you want to ensure that the discounted price is lower than the regular price:
			--> Example
				CREATE TABLE products (
					product_no integer,
					name text,
					price numeric CHECK (price > 0),
					discounted_price numeric CHECK (discounted_price > 0),
					CHECK (price > discounted_price)
				);
				INSERT INTO public.products (product_no, name, price, discounted_price) VALUES (1, 'Book', 20.00, 10.00); (VALID query because I meet the constrain)
				OUTPUT: 
					INSERT 0 1
				INSERT INTO public.products (product_no, name, price, discounted_price) VALUES (2, 'Shirt', 20.00, 30.00); (INVALID violating table constrain third one )
				OUTPUT:
					ERROR:  new row for relation "products" violates check constraint "products_check"
					DETAIL:  Failing row contains (2, Shirt, 20.00, 30.00)
			--> The first two constraints are being attached to column, the third constraint is for table constraint 
				due to written separately from any one column definition.
			--> Column constraints can also be written as table constraints
			--> Reverse is not necessarily possible, since column constraint is supposed 
				to refer to only column attached to.
			--> The example above can be also written in this 
				CREATE TABLE products (
					product_no integer,
					name text,
					price numeric,
					CHECK (price > 0),
					discounted_price numeric,
					CHECK (discounted_price > 0),
					CHECK (price > discounted_price)
				);
				CREATE TABLE products (
    				product_no integer,
    				name text,
    				price numeric CHECK (price > 0),
    				discounted_price numeric,
    				CHECK (discounted_price > 0 AND price > discounted_price)
				);
			--> It's a matter of taste.
			--> Names can be assigned to table constraints in the same way as column constraints.
			--> Example 
				CREATE TABLE products (
    				product_no integer,
    				name text,
    				price numeric,
    				CHECK (price > 0),
    				discounted_price numeric,
    				CHECK (discounted_price > 0),
    				CONSTRAINT valid_discount CHECK (price > discounted_price)
				);
		B. Not-Null Constraints
			--> A not-null constraint simply specifies that a column must not assume the null value.
			--> Example
				CREATE TABLE products (
    				product_no integer NOT NULL,
    				name text NOT NULL,
    				price numeric
				);
			--> A not-null constraint is always written as a column constraint.
			-->  A not-null constraint is functionally equivalent to creating a check constraint CHECK (column_name IS NOT NULL), 
				 but in PostgreSQL creating an explicit not-null constraint is more efficient.
			--> Example
				CREATE TABLE products (
    				product_no integer NOT NULL,
    				name text NOT NULL,
    				price numeric NOT NULL CHECK (price > 0)
				);
			--> The order doesn't matter. It does not necessarily determine in which order the constraints are checked.
			--> The NOT NULL constraint has an inverse: the NULL constraint.
			--> This does not mean that the column must be null, which would surely be useless.
			--> The NULL constraint is not present in the SQL standard and should not be used in portable applications. 
				(It was only added to PostgreSQL to be compatible with some other database systems.)
			--> Example
				CREATE TABLE products (
    				product_no integer NULL,
    				name text NULL,
    				price numeric NULL
				);
			--> TIP : In most database designs the majority of columns should be marked not null.
		C. Unique Constraints
			--> Unique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table.
			--> Example
				CREATE TABLE products (
					product_no integer UNIQUE,
					name text,
					price numeric
				);
				INSERT INTO public.products2 (product_no, name, price) VALUES (1, 'Royce', 10);
				INSERT 0 1
				INSERT INTO public.products2 (product_no, name, price) VALUES (1, 'Royce', 10);
				ERROR:  duplicate key value violates unique constraint "products2_product_no_key"
				DETAIL:  Key (product_no)=(1) already exists.
			--> When written as a column constraint 
			--> Example
				CREATE TABLE products (
					product_no integer,
					name text,
					price numeric,
					UNIQUE (product_no)
				);
			--> When written as a table constraint.
			--> To define a unique constraint for a group of columns, write it as a table constraint with the column names separated by commas
			--> Example
				CREATE TABLE example (
					a integer,
					b integer,
					c integer,
					UNIQUE (a, c)
				);
			--> This specifies that the combination of values in the indicated columns is unique across the whole table, 
				though any one of the columns need not be (and ordinarily isn't) unique.
			--> You can assign your own name for unique constraint, in usual way 
			--> Example
				CREATE TABLE products (
					product_no integer CONSTRAINT must_be_different UNIQUE,
					name text,
					price numeric
				);
			--> Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint.
			--> In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal.
			--> However, two null values are never considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns.
			--> This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable.
			--> Example
				INSERT INTO public.products2 (product_no, name, price) VALUES (null, 'Royce', 10);
				INSERT 0 1
				INSERT INTO public.products2 (product_no, name, price) VALUES (null, 'Royce', 10);
				INSERT 0 1
		D. Primary Keys
			--> A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table.
			--> This requires that the values be both unique and not null.
			--> The difference between UNIQUE and PRIMARY KEYS CONSTRAINTS is that for UNIQUE the values are identical but when null values 
				it violates constrain where as PRIMARY KEY column is UNIQUE but NOT NULL
			-->  So, the following two table definitions accept the same data
			--> Example
				CREATE TABLE products (
					product_no integer UNIQUE NOT NULL,
					name text,
					price numeric
				);
				CREATE TABLE products (
    				product_no integer PRIMARY KEY,
   					name text,
    				price numeric
				);
			--> Primary keys can span more than one column; the syntax is similar to unique constraints
			--> Example
				CREATE TABLE example (
					a integer,
					b integer,
					c integer,
					PRIMARY KEY (a, c)
				);
				 INSERT INTO public.example (a, b, c) VALUES (1,2,3);
				 INSERT 0 1
				 INSERT INTO public.example (a, b, c) VALUES (1,2,4);
				 INSERT 0 1
				 INSERT INTO public.example (a, b, c) VALUES (1,2,4);
				 ERROR:  duplicate key value violates unique constraint "example_pkey"
				 DETAIL:  Key (a, c)=(1, 4) already exists.
			--> Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, 
				and will force the column(s) to be marked NOT NULL.
			--> A table can have at most one primary key.
			--> (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.
			--> Relational database theory dictates that every table must have a primary key. 
			--> This rule is not enforced by PostgreSQL, but it is usually best to follow it.
			--> Primary keys are useful both for documentation purposes and for client applications. 
		E. Foreign Keys
			--> A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. 
			--> We say this maintains the referential integrity between two related tables.
			--> Example
				CREATE TABLE products (
					product_no integer PRIMARY KEY,
					name text,
					price numeric
				);
			--> Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. 
				So we define a foreign key constraint in the orders table that references the products table BTW this explicit way:
			--> Example
				CREATE TABLE orders (
					order_id integer PRIMARY KEY,
					product_no integer REFERENCES products (product_no),
					quantity integer
				);
			--> We say that in this situation the orders table is the referencing (child) table and the products table is the referenced (parent) table. 
				Similarly, there are referencing and referenced columns.
			--> We can shorten it implicitly
			--> Example
				CREATE TABLE orders (
					order_id integer PRIMARY KEY,
					product_no integer REFERENCES products,
					quantity integer
				);
			--> A foreign key can also constrain and reference a group of columns.
			--> As usual, it then needs to be written in table constraint form. Here is a contrived syntax example
			--> Example
				CREATE TABLE t1 (
					a integer PRIMARY KEY,
					b integer,
					c integer,
					FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
				);
			--> You can assign your own name for a foreign key constraint, in the usual way.
			--> A table can have more than one foreign key constraint.
			--> This is used to implement many-to-many relationships between tables.
			--> Say you have tables about products and orders, 
				but now you want to allow one order to contain possibly many products (which the structure above did not allow).
			--> Example
					CREATE TABLE products (
						product_no integer PRIMARY KEY,
						name text,
						price numeric
					);

					CREATE TABLE orders (
						order_id integer PRIMARY KEY,
						shipping_address text,
						...
					);

					CREATE TABLE order_items (
						product_no integer REFERENCES products,
						order_id integer REFERENCES orders,
						quantity integer,
						PRIMARY KEY (product_no, order_id)
					);
			--> Notice that the primary key overlaps with the foreign keys in the last table.
			--> We know that the foreign keys disallow creation of orders that do not relate to any products. 
			--> But what if a product is removed after an order is created that references it? SQL allows you to handle that as well.
			--> Disallow deleting a referenced product
			--> Delete the orders as well
			--> To illustrate this, let's implement the following policy on the many-to-many relationship example above: 
				when someone wants to remove a product that is still referenced by an order (via order_items), we disallow it. 
				If someone removes an order, the order items are removed as well:
			--> Example
					CREATE TABLE products (
						product_no integer PRIMARY KEY,
						name text,
						price numeric
					);

					CREATE TABLE orders (
						order_id integer PRIMARY KEY,
						shipping_address text,
						...
					);
					CREATE TABLE order_items (
						product_no integer REFERENCES products ON DELETE RESTRICT,
						order_id integer REFERENCES orders ON DELETE CASCADE,
						quantity integer,
						PRIMARY KEY (product_no, order_id)
					);
				--> ON DELETE RESTRICT pertains to disallow or prevents on deleting data
				--> ON DELETE CASCADE pertains to allow deleting data cascading where referenced(parent) row is deleted the referencing (child) will be automatically deleted.
		--> Restricting and cascading deletes are the two most common options.
		--> RESTRICT prevents deletion of a referenced row. 
			NO ACTION means that if any referencing rows still exist when the constraint is checked, an error is raised; 
			this is the default behavior if you do not specify anything.
		-->  CASCADE specifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well.
		--> ON UPDATE - which is invoked when a referenced column is changed (updated).
		--> The possible actions are the same. 
			In this case, CASCADE means that the updated values of the referenced column(s) should be copied into the referencing row(s).
		--> A foreign key must reference columns that either are a primary key or form a unique constraint.
		--> This means that the referenced columns always have an index (the one underlying the primary key or unique constraint); 
		--> so checks on whether a referencing row has a match will be efficient.
	F. Exclusion Constraints
		--> Exclusion constraints ensure that if any two rows are compared on the specified columns or expressions using the specified operators, 
			at least one of these operator comparisons will return false or null.
		--> Example
			CREATE TABLE circles (
				c circle,
				EXCLUDE USING gist (c WITH &&)
			);

Chapter 6 (Data Manipulation)
	--> Introduction data manipulation pertains to update, delete, insert table data and also returning data from modified rows.
	--> This chapter explains how to extract your long-lost data from the database.
	I. Inserting Data
		--> When a table is created, it contains no data.
		--> The first thing to do before a database can be of much use is to insert data.
		--> Data is conceptually (abstract) inserted one row at a time. 
		--> Of course you can also insert more than one row,
		--> but there is no way to insert less than one row.
		--> The insert command requires the table name and column values.
		--> Example (Implicit way)
			CREATE TABLE products (
				product_no integer,
				name text,
				price numeric
			);
			INSERT INTO products VALUES (1, 'Cheese', 9.99); 
		--> The data values are listed in the order in which the columns appear in the table, separated by commas.
		-->  Usually, the data values will be literals (constants), but scalar expressions are also allowed.
		--> Example (Explicit)
			INSERT INTO products (product_no, name, price) VALUES (1, 'Cheese', 9.99); (ORDER base on column)
			INSERT INTO products (name, price, product_no) VALUES ('Cheese', 9.99, 1); (UNORDER )
		--> Many users consider it good practice to always list the column names.
		--> If you don't have values for all the columns, you can omit some of them. 
			In that case, the columns will be filled with their default values. 
		--> Example
				INSERT INTO products (product_no, name) VALUES (1, 'Cheese');
				INSERT INTO products VALUES (1, 'Cheese');
		--> For clarity, you can also request default values explicitly, for individual columns or for the entire row:
		--> Example
				INSERT INTO products (product_no, name, price) VALUES (1, 'Cheese', DEFAULT);
				INSERT INTO products DEFAULT VALUES;
		--> You can insert multiple rows in a single command:
		--> Example
			INSERT INTO products (product_no, name, price) VALUES
				(1, 'Cheese', 9.99),
				(2, 'Bread', 1.99),
				(3, 'Milk', 2.99);
		--> When inserting a lot of data at the same time, considering using the COPY command.
	II. Updating Data
		--> The modification of data that is already in the database is referred to as updating.
		-->  You can update individual rows, all the rows in a table, or a subset of all rows.
		--> Each column can be updated separately; the other columns are not affected.
		--> To update existing rows, use the UPDATE command.
		--> This requires three pieces of information:
			a. The name of the table and column to update
			b. The new value of the column
			c. Which row(s) to update
		--> Therefore it is not always possible to directly specify which row to update.
		--> Instead, you specify which conditions a row must meet in order to be updated.
		--> For example, this command updates all products that have a price of 5 to have a price of 10:
		--> If you want to update a single row you must specify always an ID because it makes row unique
		--> If you want to update many rows you must not specify an ID.
		--> Example
			UPDATE products SET price = 10 WHERE price = 5; (NOT SPECIFYING ID and price in table that is  equal to 5  will all update)
			UPDATE products SET name = 'Bed' WHERE product_no = 1; (ID SPECIFIED SO 1 row will be update)
		-->  First is the key word UPDATE followed by the table name. 
		--> As usual, the table name can be schema-qualified, otherwise it is looked up in the path.
		--> Next is the key word SET followed by the column name, an equal sign, and the new column value.
		--> The new column value can be any scalar expression, not just a constant. 
		--> Example 
			UPDATE products SET price = price * 1.10; (scalar expression)
			UPDATE products SET price = price * 2; (scalar expression)
		--> UPDATE products SET price = price * 1.10;
		--> As you see, the expression for the new value can refer to the existing value(s) in the row.
		--> We also left out the WHERE clause. If it is omitted, it means that all rows in the table are updated. 
		-->  If it is present, only those rows that match the WHERE condition are updated.
		-->  Note that the equals sign in the SET clause is an assignment while the one in the WHERE clause is a comparison, but this does not create any ambiguity(open or interpretation).
		--> You can update more than one column in an UPDATE command by listing more than one assignment in the SET clause. 
		--> Example
			UPDATE mytable SET a = 5, b = 3, c = 1 WHERE a > 0;
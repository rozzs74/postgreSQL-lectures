Date created: July 27, 2018;
Created by Royce:

Chapter 1. (Introduction)
	I. Installation
		What is PostgreSQL? 
			--> is an object-relational database management system (ORDBMS).
			--> ORDBMS - is a database management system similar to relational database but with an object-oriented database model.
							objects, classes and inheritance are directly supported in database schemas and in the query language.
			--> Object database  - An object database is a database management system in which information is represented in the form of objects as used in object-oriented programming. 
									Object databases are different from relational databases which are table-oriented. 
									Object-relational databases are a hybrid of both approaches.
			--> Developed at the University of California at Berkeley Computer Sciene Department.
			--> Written in C and the initial release was 29 January 1997.
			--> Postgres originates(pioneer) many concepts that only became available in some commercial database systems (Oracle, MSSQL, Teradata) much later.
			--> PostgresSQL is an original ancestor of open source database in Berkeley code. It supports a large part of the SQL standard and offers many modern features like:
					a. Complex queries - Complex SQL queries go beyond the standard SQL query commands such as SELECT. For example Consider the huge amount of data that would be present in a music database like Spotify. 
										Sometimes you want to search for more than just a single artist or album or maybe you want to pull together different subsets of data.
					b. Foreign keys - A FOREIGN KEY is a key used to link two tables together.
									  A FOREIGN KEY is a field (or collection of fields) in one table that refers to the PRIMARY KEY in another table. 
									  The table containing the foreign key is called the child table, and the table containing the candidate key is called the referenced or parent table.
					c. Triggers - is special stored procedure that is run when specific actions occur within a database. 
								  Most triggers are defined to run when changes are made to table's data.
					d. Updatable views - An updatable view is one which allows performing a UPDATE command on itself without affecting any other table.
					e. Transactional integrity - A transaction is a unit of work that is performed against a database. Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
					f. Multiversion concurrency control (MCC) - is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.
							Without concurrency control, if someone is reading from a database at the same time as someone else is writing to it, it is possible that the reader will see a half-written or inconsistent piece of data. 
							For instance, when making a wire transfer between two bank accounts if a reader reads the balance at the bank when the money has been withdrawn from the original account and before it has deposited in the destination account, it would seem that money has disappeared from the bank. 
			--> Also, PostgreSQL can be extended by the user in many ways, for example by adding new
					a. Data types - boolean, characters (char, varchar, text), numbers (integer, float), temporal (date, time, timestamp, timestampz, interval), Arrays, JSON, UUID,  Special(box, line, point, lseg, polygon, inet, macaddr)
					b. Functions - also known as Stored Procedures, allow you to carry out operations that would normally take several queries and round trips in a single function within the database. Functions allow database reuse as other applications can interact directly with your stored procedures instead of a middle-tier or duplicating code.
								   Functions can be created in a language of your choice like SQL, PL/pgSQL, C, Python, etc.
					c. Operators - is a reserved word or a character used primarily in a PostgreSQL statement's WHERE clause to perform operation(s), such as comparisons and arithmetic operations.
									- Arithmetic operators
									- Comparison operators
									- Logical operators
									- Bitwise operators
					d. Aggregate functions - An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the count, sum, avg (average), max (maximum) and min (minimum) over a set of rows.
					e. Index methods - This is referring to have an enhance database performance.
					f. Procedural language - PostgreSQL allows user-defined functions to be written in other languages besides SQL and C. These other languages are generically called procedural languages (PLs).
			--> And because of the liberal license, PostgreSQL can be used, modified and distributed by anyone free of charge for any purpose, be it private, commercial or academic.
		Brief History of PostgreSQL
			--> PostgreSQL is derived from the POSTGRES package written at UCal with over two decades of development behind it. Today PostgreSQL is now the most advanced open-soruce database availble anywhere.
			--> POSTGRES (data model) project led by Professor Michael Stonebraker was sponsored by DARPA, ARO, NSF and ESL INC.
			--> The implementation of POSTGRES began in 1986.
			--> The demoware system became operational in 1987 and was shown 1988 ACM-SIGMOD conference.
			--> Version 1 released to few external users in June 1989.
			--> They came up to redesign due to critique of the first rule sytem. Version 2 was released in June 1990 with new rule system.
			--> Version 3 appeared in 1991 and added support for multiple storage managers, an improved query executor and a rewritten rule system.
			--> Beyond 1991 POSTGRES has been used to implement many different research production application. These includes the ff:
					- Financial data analysis system
					- Jet engine performance monitoring package
					- Asteriod tracking database 
					- Medical information database 
					- Several geographic information systems
					- Educational tool at several universities
			--> In late 1992 Illustra information technicalogies commercialized it and POSTGRES became the primary data manager.
			--> The size of external user community doubled nearly during 1993. The more user the more bugs came out. It became increasingly maintenance and support.
				To reduce support burden the Berkeley POSTGRES project officially ended with version 4.2.
			--> In 1994, Andrew Yu and Jolly Chen added an SQL language interpreter to POSTGRES. Under a new name, Postgres95 was subsequently
					released to the web to find its own way in the world as an open-source descendant of the original POSTGRES Berkeley code.
			--> Postgres95 was faster than Version 4.2 base on Wisconsin benchmark. There are many enhancement including bug fixes.
			--> By 1996 it became clear that the name Postgres95 would not stand test of time. We chose new name PostgreSQL to reflect the relationalship 
				between the original POSTGRES and the more recent versions with SQL capability. At the same time, we set the version number to start 6.0
		Conventions
			--> An administrator is generally a person who is in charge of installing and running the server. 
				A user could be anyone who is using or wants to use any part of the PostgreSQL system.
	II. Architectural Fundamentals: 
		--> Architectural may refer to or in short for summary server and client model.
		--> In database jargon(technical terminology), PostgresSQL uses client / server models.
		--> PostgresSQL session consists of cooperating processes (running programs behind it).
			A. Server Process - This is for server process operations.
				- Manages database files.
				- Connections to the database from client applications.
				- Performs database actions on behalf of clients.
				- The database server program is called "POSTGRES".
			B. User - frontend application and user developer.
				- A front end application that wants to perform database operations.
				- Different types of application may refer to platform type of application.
					1. CLI - A client could be a text-oriented tool. For example task automations, library SDK.
					2. GUI - A graphical user interface application. For example desktop apps, web apps, mobile apps.
					3. Hosting environment - A web server that accesses the database to display web pages, or a specialized
									database maintenance tool. 
					4. Other - Some client applications are supplied with the PostgreSQL distribution; most are developed by users.
		--> PostgreSQL architectural model (server and client) they communicate over a TCP / IP network connection.
		--> Keep in mind the files that can be accessed on a client machine might not be accesseble. (or may accessible using a file name) on machine.
		--> PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts "fork" (replicating) a new process
			for each connection. The concept behind this statement is that tha postgres server is self replicating invocation. In short 
				it replicate itself rather than accepting connection.
		--> Master server(replicated postgres) is always running waiting for client connections. Whereas client and associated server processes  come and go.
		--> All this processes are invisible to the user. We are metion it here for completeness.

Chapter 2 (THE SQL LANGUAGE)
	I.Concepts
		--> PostgreSQL is relational database management system (RDBMS).That means it is a system for managing data stored in relations.
		--> Relation is essentially a mathematical term for table.
		--> Each table is a named collection of rows.
		--> Each row of a given table has the same set of named columns.
		--> Each column is of a specific data type.
		--> Tables are grouped into databases,  and a collection of databases managed by a single PostgreSQL server instance 
			constitues a database cluster.
	II. Creating a new table
		--> You can create new table by specifying the table name along with column names and their types.
			Example
				CREATE TABLE weather (
					city 		varchar(80),
					temp_lo 	int,  -- low temperature
					temp_hi 	int,  -- high temperature
					prcp		real  -- precipitation  real is 6 digits value only
					date		date
				)

				CREATE TABLE cities (
					name varchar(80),
					location point -- Geometric data type
				)
	III. Populating a table with Rows 
		--> INSERT statement is used to populate a table with rows.
			Example:
			--> Implicit way
				INSERT INTO weather VALUES ('San Francisco'), 46, 50, 0.25, '1994-11-27');
				INSERT INTO city VALUES ('San Francisco', '(-194.0, 53.0)');
			--> Explicit way 
				INSERT INTO weather (city, temp_lo, temp_hi, prcp, data) 
					VALUES ('San Francisco'), 46, 50, 0.25, '1994-11-27');
		--> For insert you can lst the columns in a different order if you wish.
		--> Many developers consider explicitly listing the columns better style than relying on the order of implicitly.
	IV. Querying a Table
		--> Quired is to retrieve data from a table.
		--> An SQL SELECT statement is used to do this.
			Example
				SELECT * FROM weather;
				--> * is a shorthand for all columns with this -> SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
				--> You can write expressions not just simple column references.
					-> SELECT city, (temp_hi + temp_lo) / 2 AS temp_avg, date FROM weather;
				--> AS - a clause that is used to relabel the output column.
				--> WHERE - a clause that specifies which rows are wanted. It contains Boolean (truth value) expression usally (AND, OR and NOT)
					-> SELECT * FROM weather WHERE city = 'Antipolo City' AND prcp > 2;
				--> ORDER - a clause that sort rows in order.
					-> SELECT * FROM weather ORDER BY city;
					-> SELECT * FROM weather ORDER BY city, temp_lo;
				--> DISTINCT - a clause that removes duplicate rows from the query result.
					-> SELECT DISTINCT city FROM weather ORDER by city;
		Notes:
			1. While SELECT * is useful for off-the-cuff queries, it is widely considered bad style in production code. 
				Since adding a column to the table would change the results.
	V. JOINS BETWEEN TABLES
		--> Thus far, our queries have only accessed one table at time.
		--> Queries can access multiple tables at once, or access the same table in such a way that multiple rows 
			of the table are being processed at the same time.
		--> Join - A query that accesses multiple rows of the same or different tables at one time.
		--> This statement is only a conceptual model. The join is usally performed in a more efficient manner.
		--> It is widely considered good style to qualify all column names in a join query, so that the query won't faile of a 
		duplicate column name is later added to one of the tables.
		--> Example
			SELECT * FROM weather, cities WHERE city = name;
			Types of JOIN
		--> Inner JOIN (http://prntscr.com/k7u9nu) (I)
			--> The SQL INNER JOIN is akin to set intersection
			--> Keyword is Intersect
			--> Selects rows from table1 and table2 where they match the selecting column.
			--> Example of Inner JOIN Concept http://prntscr.com/k7ufzp
			--> Example
				SELECT * FROM weather INNER JOIN cities ON (weather.city = cities.name);
		--> LEFT OUTER JOIN 
			--> Example
				SELECT * FROM weather LEFT OUTER JOIN CITIES ON (weather.city = cities.name)
		--> SELF JOIN
			--> We can also join a table against itself. This is called a self join.
			--> Example
			 	SELECT W1.city, W1.temp_lo AS low, W1.temp_hi as high, W2.city, W2.temp_lo AS low, W2.temp_hi as high FROM weather W1, weather W2 WHERE W1.temp_lo < W2. temp_lo AND W1.temp_hi > W2.temp_hi;
			--> Here we have relabeled the weather table as W1 and W2 to be able to distinguish the left and right side of the join.
			--> We can use this kind of aliases in other queries to save some typing.
			--> Example	
				SELECT * FROM weather w, cities c WHERE w.city = c.name;
			--> We will encounter this style of abbreviating quite frequently.
	VI. Aggregate Functions
		--> Like most other relational database products, PostgreSQL supports aggregate functions.
		--> Aggregate function - computes a single result from multiple input rows.
		--> Aggregate function - produced a single result for an entire group or table.
		--> Aggregate function -  are used to produce summarized results.
		--> Aggregate function - They operate on sets of rows. They return results based on groups of rows. By default, all rows in a table are treated as one group.
		--> Types of aggregate function that computes over a set of rows.
			A. count - This function returns the number or rows or non NULL values for a column
			b. sum   - This function returns the sum of a selected column.
			c. avg (average) - This function returns the average value for a specific column. 
			d. max (maximum) - This function returns the largest value of a specific column.
			e. min (minimum) - This function returns the smallest value of a specific column. 
		--> Example
			SELECT count(W1.temp_lo) FROM weather W1;
			SELECT sum(W1.temp_lo) FROM weather W1;
			SELECT avg(W1.temp_lo) FROM weather W1;
			SELECT max(temp_lo) FROM weather;
			SELECT min(temp_lo) FROM weather;
		--> Aggregate functions cannot be used inside WHERE claused. This restriction exists because the WHERE clause 
			determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before 
			aggregate functions are computed.
			SELECT city FROM weather WHERE temp_lo = max (temp_lo); # WRONG 
			SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather); # CORRECT
		--> This is valid because the subquery is an indenpendent computation that computes its own aggregate separately from 
			what is happening in the outer query.
		--> Aggregates also very useful in combination with GROUP BY clauses. For example we can get the maximum low temperature observed in each city.
		--> Example
			SELECT city, max(temp_lo) FROM weather GROUP BY city;
			SELECT w.city, max(w.temp_lo) FROM weather w GROUP BY w.city;
		--> Each aggregate result is computed over the table rows matching that city. We can filter these grouped row using HAVING
		--> Example
			SELECT city, max(temp_lo) FROM weather GROUP by city HAVING max(temp_lo) < 40;
		--> SELECT city, max(temp_lo) FROM weather WHERE city LIKE 'S%' GROUP BY city HAVING max(temp_lo) < 40;
		--> The LIKE operator does pattern matching
		--> The understanding and interaction between aggregates SQL WHERE and HAVING caluses.
		--> WHERE - selects input rows BEFORE groups and aggregates are computed (it controls which rows go into the aggregate computation).
		--> HAVING - whereas HAVING selects group rows AFTER groups and aggregates computed.
		--> Thus, the WHERE clause must not contains aggregate functions; it makes no sense to try to use an aggregate to determine 
			which rows will be inputs to the aggregates.
		--> On the other hand, the HAVING clause always contains aggregate functions. (Stricly speaking, you are allowed to write a HAVING clause 
		that doesn't user aggregates) but it's seldom useful.
	VII. Updates
		--> You can update existing rows using the UPDATE command.
		--> Example
			UPDATE weather SET temp_hi = temp_hi -2, temp_lo = temp_hi -2 WHERE date > '1994-11-28';
	VIII. Deletions
		--> Rows can be removed from a table using DELETE command. 
		--> Example
			DELETE FROM weather WHERE city = 'Hayward';
		--> To remove all rows from a given table, leaving it empty. (THE SYSTEM WILL NOT REQUEST CONFIRMATION BEFORE DOING THIS!)
			DELETE FROM <tablename>
			DELETE FROM weather;
Chapter 3 (Advanced Features)
	I. Introduction
		--> We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your 
			data. We will look some PostgreSQL extensions.
	II. Views
		--> Views are pseudo-table (Implicit).
		--> A view can contain all rows of a table or selected rows from one or more tables.
		--> A view can be created from one or many tables, which depends on the written PostgreSQL query to create a view.
		--> Views allow you to encapsulate the details of the structure of your tables, which might change as your 
		application evolves, behind consistent interfaces.
		--> A view can represent a subset of a real table, selecting certain columns or certain rows from an ordinary table. 
		--> A view can even represent joined tables.
		--> Because views are assigned separate permissions, you can use them to restrict table access so that the users see only specific rows or columns of a table.
		--> Views, which are kind of virtual tables, allow users to do the following
			1. Structure data in a way that users or classes of users find natural or intuitive.
			2. Restrict access to the data such that a user can only see limited data instead of complete table.
			3. Summarize data from various tables, which can be used to generate reports.
		--> Example
			1. CREATE VIEW myview AS 
				SELECT city, temp_lo, temp_hi, prcp, date, location FROM weather, cities WHERE city = name;
			2. SELECT * FROM myview;
		--> Droppin Views 
			DROP VIEW <view_name>;
			DROP VIEW myview;
	III. Foreign keys	
		--> A concept behind foreign keys is you want to make sure that no one can insert rows in the weather table that do not 
			have a matching entry in the cities table. This is called maintaining referential integrity of your data.
		--> In simplistic database systems this would be implemented (if at all).
		--> Example
			CREATE TABLE cities (
				city VARCHAR(80) PRIMARY KEY,
				location POINT 
			);
			CREATE TABLE weather (
				city VARCHAR(80) REFERENCES cities(city),
				temp_lo INT, 
				temp_hi INT,
				prcp REAL,
				date DATE
			);
			INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
			ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
			DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
			* To fix this need to insert first into cities table because it reference to weather table.
	IV. Transactions
		--> A transaction is a unit of work that is performed against a database.
		--> Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
		--> A transaction is the propagation of one or more changes to the database. 
			For example, if you are creating a record, updating a record, or deleting a record from the table, then you are performing transaction on the table. 
			It is important to control transactions to ensure data integrity and to handle database errors.
		--> Properties of transaction
			1. Atomicity - Ensures that all operations within the work unit are completed successfully; otherwise, the transaction is aborted at the point of failure and previous operations are rolled back to their former state.
			2. Consistency - Ensures that the database properly changes states upon a successfully committed transaction.
			3. Isolation - Enables transactions to operate independently of and transparent to each other.
			4. Durability -  Ensures that the result or effect of a committed transaction persists in case of a system failure.
		--> Transaction control 
			1. BEGIN - to start transaction.
			2. COMMIT - to end transaction.
			3. ROLLBACK - to rollback the changes.
		--> Transactions - are a fundamental concept of all database systems. The essential point of a transaction is that 
			it bundles multiple steps into single, all-or-nothing operation. The intermediate states between the steps 
			are not visible to other concur transactions, and if some failure occurs that prevents the transaction 
			from completing, the none of the steps affect the database at all.
		--> A transaction is said to be atomic from the point of view of other transactions it either happens completely or 
			not at all.
		--> Example
			UPDATE accounts SET balance = balance - 100.00
    			WHERE name = 'Alice';
			UPDATE branches SET balance = balance - 100.00
    			WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
			UPDATE accounts SET balance = balance + 100.00
    			WHERE name = 'Bob';
			UPDATE branches SET balance = balance + 100.00
   				 WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
		--> The details of these commands are not important here; the important point is that there are several separate updates 
			involved to accomplish this rather simple operation.
		--> We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has 
			been permanently recorded and won't be lost even if a crash ensues shortly thereafter.
		--> Another important property of transactional database is closely related to the notion of atomic updates:
			when multiple transactions are running concurrently, each one should not be able to see the incomplete changes 
			made by others.
		--> Transaction is being used for banking transaction.
		--> Example 
			BEGIN;
				<SQL STATEMENT>
			COMMIT;
			BEGIN;
				UPDATE accounts SET balance = balance - 100.00
					WHERE name = 'Alice';
			-- etc etc 
			COMMIT;
		--> If the balance went negative value, we can issue the command ROLLBACK instead of COMMIT, and all our updates so 
			far will be canceled.
		--> If you do not issue a BEGIN command in the statement, each invidual statement has an 
			implicit BEGIN and (if successful) COMMIT wrapped around it.
		--> A group of statements surrounded by BEGIN and COMMIT is sometimes called transactional block.
		--> It's possible to control the statement in a transaction in more granular (appearing) fashion
			through the use of savepoints.
		--> Savepoints - allow you to selectively discard parts of the transaction, while committing the rest.
		--> After defining a savepoint with SAVEPOINT, you can if needed roll back to the savepoint with 
			ROLLBACK TO. All the transaction's database changes between difning the savepoint and rolling back 
			to it are discarded, but changes earlier thatn the savepoint are kept.
		--> After rolling back to a savepoint, it continues to be defined. Meaning if you came back to a savepoint the current state 
			will be based on it. So you can roll back to it several times.
		--> All this thing is happening within transactional block, so nont of it is visible to other database sessions.
		--> When and if you commit the transactional block, the committed actions become visible as a unit to other sessions.
		--> While the rolled-back actions never become visible at all.
		--> Example
			BEGIN;
				UPDATE accounts SET balance  = balance - 100.00 WHERE name = 'Alice';
			SAVEPOINT my_savepoint;
				UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob';
			ROLLBACK TO my_savepoint;
				UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Walley';
			COMMIT;
		--> This example is of course oversimplified but there's a lot of control possible in a transaction block 
			through the use of savepoints. 
		--> Moreover ROLLBACK TO is the only way to regain control of transaction block that was put in aborted state
			by the sytem due to an error, short of rolling it back completely and starting again.
	V. Window Functions
		--> The term window describes the set of rows on which the window function operates. A window function returns a value from the rows in a window.
		--> Window function - performs a calculation across a set of table rows that are somehow related 
			to the current row. This is comparable to the type of calculation that can be done with aggregate function.
		--> Aggregate functions reduces the number of rows returned by the queries but window functions operates in set of rows, but 
			it does not reduce the number of rows returned by the query.
		--> However, window functions do not cause rows to become grouped into a single output row lie non-window aggregate calls would.
		--> Example
			SELECT depname, empno, salary avg(salary) OVER (PARTITION by depname) FROM empsalary;
		--> A window function call always contains an OVER clause directly following the window function's name and argument(s).
		--> This is what syntactically distinguishes it from a normal function or non-window aggregate.
		--> The OVER clause determines exactly how the rows of the query are split up for processing by the window function.
		--> The PARTITION By clause within OVER divides the rows into groups, or partitions that share the same values f the PARTITION BY expression.
		--> You can also control the order in which rows are processed by window functions using ORDER BY within OVER.
		--> Example
			SELECT depname, empno, salary, rank() OVER (PARTITION by depname ORDER BY salary DESC) FROM empsalary;
		--> As from the query the rank() function produces a numerical rank for each distinct ORDER BY value in the current 
			row's position.
		--> There is another import concept associated with window functions: for each row, there is a set of rows 
			within its partition called its window frame.
		--> Some window functions act only on the rows of the window frame, rather than of the whole partition.
		--> Example
			SELECT salary, sum(salary) OVER () FROM empsalary;
			SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
	VI. Inheritance 
		--> Inheritance is a concept from object-oriented databases. It opens up interesting new posibilities of database design.
		--> Example
			A. Normal way 
				CREATE TABLE capitals (
					name       text,
					population real,
					altitude   int,    -- (in ft)
					state      char(2)
				);
				CREATE TABLE non_capitals (
					name       text,
					population real,
					altitude   int     -- (in ft)
				);
				CREATE VIEW cities AS
				SELECT name, population, altitude FROM capitals
					UNION
				SELECT name, population, altitude FROM non_capitals;
			B. Inheritance way (better solution is this):
				CREATE TABLE cities (
					name 		text,
					population  real,
					altitude 	int
				);
				CREATE TABLE capitals (
					state char(2),
				) INHERITS (cities);
			--> In this case, a row of capitals inherits all columns (name, populate, altitude) from its parent cities.
			--> In PostgreSQL, a table can inherit from zero or more other tables.
			--> Example a query finds names of all cities including state capitals
				SELECT name, altitude FROM cities WHERE altitude > 500;
			--> Since capitals inherit all of columns in cities the result set for this query are combined capitals and cities.
			--> Example a query that finds all the cities that are not state capitals
				SELECT name, altitude FROM ONLY cities WHERE altitude > 500;
			--> The output for this query is for parent only.
			--> Here the ONLY before cities indicates that the query should over only the cities table, and not tables below cities
				in the inheritance hierarchy.
			--> SELECT, UPDATE and DELETE  supports this ONLY clause notation.
Chapter 4 SQL Syntax
	I. Lexical structure	
		A. Introduction
			--> SQL input consists of a sequence of commands.
			--> A command is composed of a sequence of tokens, terminated by a semicolon (";").
			--> The end of the input stream also terminates a command.
			--> Which tokens are valid depends on the syntax of the particular command.
			--> Tokens - in SQL is a sequence or group of SQL characters separated by comments, whitespace or oher SQL special character.
			--> Tokens - The basic syntactical units of the SQL language are called tokens. A token consists of one or more characters of which none are blanks, control characters, or characters within a string constant or delimited identifier.
			--> A token can be
				1. key word  such as SELECT or INSERT
				2. Identifier - identify names of tables, columns or other database objects. For example MY_TABLE, A
				3. Quoted identifier 
				4. literal (or constant) or a special character symbol. Such as literal (123, 'John') special character ((), =)
			--> Tokens are normally separated by whitespace (space, tab, newline)
			--> Example the ff syntactically valid SQL input
				SELECT * FROM MY_TABLE;
				UPDATE MY_TABLE SET A = 5;
				INSERT INTO MY_TABLE VALUES (3, 'hi there');
			--> Additionally, comments can occur in SQL input. Ther are not tokens, they are effectively equivalent to whitespace.
			--> The SQL 
		B. Identifiers and Key Words
			--> Tokens such as SELECT, UPDATE, or VALUES in the example above are example of key words. In which words that 
				have fixed a meaning in the SQL language.
			--> The tokens MY_TABLE and A are example of identifiers because they identify name of tables, columns or database objects depending 
				on the command they are used in.
			--> SQL identifiers and key words must begin with 
				1. letter (a-z, but also letters with diacritical marks and non-Lating letters)
				2. underscore _
				3. digits (0-9)
			--> Example
				UPDATE MY_TABLE SET A = 5;
				- can be equivalent be written as 
				uPDaTE my_TabLE SeT a = 5;
			--> A convention often used is to write key words in upper case and names in lower case.
			--> Example
				UPDATE my_table SET a = 5;
			--> There is second kind of identifier: the delimited or quoted identifier. It is formed by enclosing 
				an arbitrary sequence of characters in double-quotes (""). 
			--> A delimited identifier is always an identifier, never a key word.So "select" could be used to refer to column or 
				table named "select", whereas an unqouted select would be taken as a key word and would therefore provoke a parse error 
				when used where a table or column name is expected.
			--> Example
				UPDATE "my_table" SET "a" = 5;
			--> Quoted identifiers can contain any character, except the character with code zero.

			